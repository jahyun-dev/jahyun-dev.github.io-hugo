+++
date = "2018-07-07T14:17:27+09:00"
title = "Repository와 Service"
author = "구자현"
draft = true
tags = ["DDD","Programming"]
categories = ["Programming"]
description = "ddd description"
+++

DDD는 Entity, Value Object, Aggregate와 같은 패턴 집합으로 바라보거나, 프레임워크 레벨에서 지원하는 구현 기법으로 인식하는건 DDD에 대한 단편적인 시각이다.
DDD의 핵심은 소프트웨어 개발과 관련된 본질적 측면으로 우리를 인도한다는 것이다.

분석과 설계의 근본적인 차이는, 분석은 도메인을 이해하는 것인 반면, 설계는 도메인을 지원하는 소프트웨어를 이해하는 것이라는 점이다.
이 둘은 밀접하게 연결되어 있으며 경계가 모호할때가 많다. 그러나 뚜렷할 필요는 없다. 유용성보다 순수성을 강조해서는 안 된다.

객체 지향의 중요한 개념은, '문제 도메인에 존재하는 개념과 관계를 찾아 이를 반영하는 소프트웨어를 설계하라'이다. 
최소 두 가지 원칙을 준수함으로써 표현적 차이, 또는 개념적 차이를 ㅚ소화하는 시스템을 개발할 수 있다.
코드가 도메인 모델을 떠오르게 하고 도메인 모델을 바탕으로 예측 가능한 방식으로 작동할 경우 두 모델 간의 '표현적 차이가 적다'라고 한다.

인프라스트럭처에 대한 의존성 없는 순수한 객체 지향 시대로의 회귀. POJO(Plain Old Java Object)라는 명칭을 부여하다.
Spring과 Hibernate. 인프라스트럭처에 대한 이ㅡ존성을 가지지 않는 순수한 객체인 POJO에 분산, 트랜잭션, 퍼시스턴스, 보안 등과 같은 인프라스트럭처 서비스를 제공할 수 있게 한다.
즉, 비침투적인 프레임워크를 제공함으로 기술적인 수준에서 표현적 차이를 줄일 수 있는 기반을 마련했다.

마틴 파울러가 "엔터프라이즈 애플리케이션 아키텍쳐 패턴"이란 책을 통해 순수한 객체 지향 원칙에 따라 속성과 메소드를 하나의 객체에 두도록 도메인 레이어를 구축하는 DOMAIN MODE 패턴을 소개.
POJO와 DOMAIN MODEL 패턴의 목표를 동일. 표현적 차이를 줄이는 것이다.


소프트웨어가 기술이 아닌 도메인에 의해 주도되어야 한다! => Eric Evans의 DDD 책 출판
DDD는 소프트웨어의 본질적인 문제인 복잡성을 제어하기 위해 기존ㅇ ㅔ존재하던 다양한 방법, 기법들을 패턴 어넝 형식으로 정리해 놓은 것 뿐임.
열광하는 이유는 DDD의 접근 방식. 소프트웨어 개발의 베스트 프랙티스를 도메인이라는 컨텍스트 안에서 체계적으로 조합하고 연결.
"모든 소프트웨어 복잡성은 도메인에 기인한다"는 매우 일반적이고 직관적인 명제로부터 출발.


## Model과 Domain Driven Design

Model은 대상을 단순화한 것. 모델은 추상화다. 즉, 복잡한 사실에 대한 하나의해석이며, 문제를 해결하기 위해 필요한 측면을 강조하고 문제 해결에 무관하거나 불필요한 세부사항에는 의도적으로 주의를 기울이지 않는다.
현실이라는 기반 위에 해결하고자 하는 문제에 적합한 추상화 계층을 창조하는 과정이다.


소프트웨어를 사용할 사용자의 활동이나 관심사의 대상이 되는 영역을 소프트웨어의 Domain이라고 한다.
따라서 Domain Model이란 소프트웨어가 문제를 해겨랳야 하는 대상영역을 단순화하고 추상화한 것이다.

훌룡한 도메인 모델은 아래 세 가지 요구사항을 만족한다.

- 모델과 핵심 설계는 상호 영향을 주고 받으며 구체화된다.
- 모델은 모든 팀 구성원들이 사용하는 언어의 근간을 이룬다.
- 모델은 불순물을 걸러낸 핵심 지식만을 포함한다.


Model Driven Design이란?
도메인 모델을 반영하는 코드를 작성. 
분석/설계/구현이 개별적인 활동이라는 환상에서 벗어나라. 이를 하나의 사이클로 묶음으로써 모델과 코드 간의 거리를 좁히도록 노력해야 한다.
모델링과 구현이 개별적인 사람들에 의해 이루어져야 한다는 착각 역시 MDD를 방해하는 요소다.

## DDD의 패턴

Entity, Value Object, Aggregate, Service, Repository, ...

> Entity
Entity의 개념은 Reference Object와 동일하다. Enitty는 식별자를 가지고 추적 가능하며 연속성을 가지는 도메인 개념이다. Entity는 속성이 아닌 식별자로 구분된다.
반면 Value Object는 식별자가 아닌 속성으로 구별되고 일반적으로 Value Object의 생명주기는 Entity에 종속된다. 
Entity는 도메인 내에 존재하는 개념의 연속성을 강조한다. 따라서 Entity라는 용어는 단순히 시스템 내에 존재하는 객체만을 지칭하지 않는다. Entity는 표현 매체의 특성이나 기술에 독립적이다.
Entity는 도메인 객체의 표현 형태를 초월해서 동이랗ㄴ 도메인 개념의 추적성과 유일성을 강조한다.
Entity라는 용어를 사용함으로써 메모리 삽입 고객 객체와 데이터베이스에 저장된 고객 테이블의 레코드를 동일한 대상으로 바라볼 수 있다.

> Domain Model Pattern
상태와 행위를 함께 가지는 풍부한 객체 모델로 도메인 레이어를 구성하는 것
Domain Model 패턴이 객체 지향의 모든 특징을 활용하기 때문에 영속성 메커니즘을 주도하는 관계형 데이터베이스와 임피던스 불일치 문제가 발생한다.

> Data Mapper
객체와 관계형 데이터베이스 간의 독립성을 보장할 수 있도록 객체와 데이터베이스 테이블 간의 데이터를 이동시키는 객체를 Data Mapper라고 한다. Data Mapper를 구현한 소프트웨어를 ORM이라고 한다.

## DDD 필요한가?

DDD는 매우 복잡하고 잘 정의된 비지니스 모델에 초점을 맞추어야 하는 소프트웨어에 적절하다.
모든 소프트웨어 애플리케이션의 95%는 'DDD를 적용하기에 적절하지 않은' 범주에 속할 것이다.
대부분의 소프트웨어는 근본적으로 데이터 중심적. 대부분의 웹사이트가 그렇다. 데이터를 수정하고 보고하는 대부분 애플리케이션은 데이터 중심적이다.
나머지 부류 또한 매우 복잡한 도메인을 가진 경우는 많지 않다. 단순하거나 규모가 크더라도 복잡하지 않다.

비록 애플리케이션이 DDD에 적합한 5%가 아니더라도 DDD에는 대량의 지혜와 경험이 녹아 있다. 자신의 상황에 적용할 수 있다고 생각되는 기법을 저굥하면 소프트웨어가 좀 더 유연해지고, 사용자에게 더 잘 반응하며, 이해하기 더 쉬워짐을 알게 될 것이다.

개발자들이 [도메인에 대한] 통찰을 얻기 위해 적용할 수 있늒 체계적인 사고 방법이 존재한다. 무질서하게 뻗어 나가는 소프트웨어 애플리케이션에 질서를 부여할 수 있는 설계 기법 역시 존재한다. 이런 기술을 연마한다면 익숙하지 않은 도메인을 접하게 될 경우에도 더 가치 있는 개발자로 발전핛 수 있게 될 것이다.


# DDD

데이터베이스와 같은 영속성 메커니즘이 끼어드는 순간 세상은 급격하게 일그러진다.

# Aggregate

변경에 대한 불변식을 유지하기 위해 하나의 단위로 취급되면서 변경의 빈도가 비슷하고, 동시 접근에 대한 잠금의 단위가 되는 객체의 집합을 Aggregate라고 한다.
데이터 변경 시 하나의 단위로 취급할 수 있는 연관된 객체들의 클러스터다. 각 Aggregate는 root와 boundary를 가진다.

Entry Point는 Aggregate를 대표하는 Reference Object로 Aggregate에 속한 객체 그룹을 항해하기 위한 시작 위치를 제공한다. Entry Point는 전역 식별자(identity)를 가진다. 외부에서는 Entry Point 이외의 다른 객체들에 직접 접근할 수 없으며 오직 Entry Point로부터의 항해를 통해서만 접근 가능하다.


# Repository

Repository는 Aggregate의 Entry Point에 대해서만 할당한다. Repository는 객체 그래프에 대한 무분별한 접근을 지향하고 통제되고 제어된 방식으로 객체에 접근하고 항해할 수 있도록 한다. 이처럼 Aggregate는 Repository를 통해 접근해야 할 도메인 객체와 연관 관계 항해를 통해 접근해야 할 도메인 객체를 명확히 구분함으로써 효율적인 객체 항해를 위한 지침을 제공한다.

Aggregate, Entry Point, Repository는 유용한 분석 기법인 동시에 도메인 객체에 대한 메모리 컬렉션 관점을 데이터베이스와 동시 실행 컨텍스트를 기반으로 한 엔터프라이즈 어플리케이션 환경으로 자연스럽게 이어주는 구현 기법이기도 하다.

# 도메인 객체의 생명주기

객체와 관계형 테이블 간의 거리는 너무 멀다. 관계형 데이터베이스는 수학적인 집합 개념을 그 기반으로 하며 정규화를 통해 데이터의 중복을 제거하는 것이 목적이다. 이에 비해 객체 지향은 객체 또는 객체들간의 응집도와 결합도를 고려한 책임 할당과 행위의 다형성을 기반으로 한다. 관계형 DB는 상속성, 캡슐화, 다형성과 같은 객체 지향의 핵심적인 개념을 지원하지 않는다.

임피던스 불일치의 어려움은 엔터프라이즈 애플리케이션 아키텍쳐에 큰 영향을 끼쳤다. 초기엔 데이터베이스 테이블에 매핑하기 쉬운 구조로 도메인 레이어를 설계했다. 겨로가적으로 객체지향 언어로 개발된 절차적 방식의 어플리케이션이라는 사생아가 탄생했다. 이 패턴은 Anemic Domain Modle을 가지는 Transaction Script 패턴으로, 엔터프라이즈 어플리케이션 아키텍쳐의 주를 이루고 있다.


행위와 상태를 함께 가지는 객체를 사용해 도메인 레이어를 설계하는 방식을 Domain Model 패턴이라고 한다. 이는 상속성, 캡슐화, 다형성과 같은 모든 객체 지향 기법들을 활용하기 때문에 임피던스 불일치 문제를 해결 하기 위한 하부 인프라스트럭쳐 지원 없이는 적용하기 쉽지 않다.

방법 중 하나는 객체 계층과 관계형 데이터베이스 계층 사이에 가상의객체 지향 데이터베이스를 구축하는 것이다. 이처럼 객체와 관계형 데이터베이스 테이블 간의 불일치를 소프트웨어적으로 해결하는 것을 객체-관계 매핑이라고 하며, 객체 관계 매핑을 수행하는 객체 관계 매퍼(Object-Relation Mapper, ORM)이라고 한다.

ORM은 내부적으로 Data Mapper 패턴을 사용한다.


# ORM과 투명한 영속성

코드와 모델을 밀접하게 연관시키는 것은 코드에 의미를 부여하고 모델을 적절하게 한다.
전체 시스템의 결합도를 낮추기 위해 의존성 주입을 지원하는 Spring 프레임워크 도입. 데이터베이스 로직을 캡슐화하기 위해 Repository를 리팩토링해 인터페이스와 구현 클래스로 분리

## 패턴, 꼭 써야 하고 따라야 하나?

문제는 패턴 그 자체에 있는 것이 아니라 패터능ㄹ 사용하는 우리의 접근 방식에 있다. 패턴을 설계 그 자체라고 생각하고 코딩 과정에서 오는 피드백을 무시하는 태도입니다.
패턴 무용론을 주장하는 것이 아니고 패턴을 가치있고 효과적으로 사용하기 위한 방안을 탐구하고자 하는 것이다.

